% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reginv.R
\name{reginv}
\alias{reginv}
\title{Confidence Interval for a Parameter using Regression Inversion}
\usage{
reginv(
  data,
  getT,
  simulateData,
  q = 0.5,
  paramInits,
  iterMax = 1000,
  eps = 1e-05,
  method = "rq",
  a = 0,
  stats = NULL,
  ...
)
}
\arguments{
\item{data}{Dataset we want to use for inference}

\item{getT}{A function to compute the statistic that will be used for inversion, as a function of \code{data}, the target parameter \code{theta}, and any additional arguments listed in \code{...}.}

\item{simulateData}{A function to simulate data from the assumed model, as a function of the target parameter \code{theta} and any additional arguments listed in \code{...}.}

\item{q}{A scalar value between 0 and 1 specifying the quantile at which we want to solve for \code{theta}. Defaults to \code{0.5}}

\item{paramInits}{A vector of initial values of \code{theta} to try. Must have at least two unique values in it, but this algorithm is more stable if you give it a dozen or so.}

\item{iterMax}{Maximum number of values of \code{theta} to generate new test statistics at.}

\item{eps}{Convergence tolerance for \code{theta}, defaults to \code{1.e-5}.}

\item{method}{The regression method employed for inversion. \code{'rq'} (default) uses quantile linear regression, \code{'rq2'} uses quantile quadratic regression,
\code{'wrq'} downweights influential values before using quantile linear regression, \code{'prob'} uses probit linear regression on an indicator variable for whether or not the observed test statistic \code{getT(data)} has been exceeded.}

\item{a}{A scalar value determining where to simulate the next value of \code{theta} at, relative to our best current estimate of it. \code{a=0} (default) simulates the next statistic at our current best estimate of \code{theta},
\code{a=1} simulates at the value the mean of all previous estimates equals our best estimate, intermediate values take a weighted mean of these two options.}

\item{stats}{A data frame of previous results to be read in to assist in calculations. Should be used with care. Data frame should contain the test statistics (labelled as \code{T}) and the values of \code{theta} at which data were simulated.}

\item{...}{Further arguments passed through to \emph{both} the \code{getT} and \code{simulateData} functions.}
}
\value{
This function returns an object of class "reginv" with the following components:

 \item{theta}{ a vector of estimated extinction times at each of a set of quantiles specified in \code{q}. (If \code{q} was not specified as input, this defaults to the lower limit for a \code{100(1-alpha)}\% confidence interval, a point estimate at \code{q=0.5} ("best estimate" of extinction time), and an upper limit for a \code{100(1-alpha)}\% confidence interval.)}
 \item{B}{ a vector containing the number of Monte Carlo samples used to estimate each \code{theta}.}
 \item{q}{ the quantile used in estimation.}
 \item{call }{ the function call}
}
\description{
Estimates a confidence interval for a parameter using regression inversion, given a model to simulate data from (as a function of this parameter)
and a function to compute a test statistic, given a sample of data.
}
\details{
How well this works depends how well-chosen \code{getT} is (a maximum likelihood estimator, if available, is a great choice).
If there are nuisance parameters, their estimates could be passed as additional arguments (\code{...}) but a better approach is to write a function that can estimate these from \code{data} at any given input value of \code{theta}.
Then this function is called inside \code{simFn}, which in effect makes the simulation model a function of \code{theta} only.
}
\examples{
# Find the lower 2.5\% confidence bound on the variance for a
# mean-zero Gaussian sample, using mean of squared observations as statistic

dat = rnorm(20, mean=0, sd=1) #simulating some random data
meanSq = function(x,n){sum(x^2)/n}
simNorm = function(x,n){rnorm(n,mean=0,sd=sqrt(x))}

reginv(dat, getT=meanSq, simulateData=simNorm, q=0.025, 
       paramInits=seq(0.5,2,length=20), n=length(dat))
       
# Compare to the exact value:
print( sum(dat^2)/qchisq(0.975,20) )
}
